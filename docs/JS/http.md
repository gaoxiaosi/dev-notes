# http

------

### GET、POST、PUT区别：

- 安全性：get直接把参数放到url中，相对post来说不太安全，可以直接在浏览器的历史记录中找到
- 请求长度：浏览器对url长度是有限制的，因此会影响get发送请求数据的长度，看浏览器一般是几K吧。
- 参数类型：post可以多种类型，get只能字符串，有时候可能还会涉及的转码解码的问题
- 缓存：浏览器一般对get请求会有缓存，post很少
- PUT主要用来修改数据的内容，不会增加数据的种类，更新数据。POST可能会改变数据种类，创建数据。

### HTTP Request Header常见请求头：

- Accept:浏览器能够处理的内容类型

- Accept-Charset:浏览器能够显示的字符集

- Accept-Encoding：浏览器能够处理的压缩编码

- Accept-Language：浏览器当前设置的语言

- Connection：浏览器与服务器之间连接的类型

- Cookie：当前页面设置的任何Cookie

- Host：发出请求的页面所在的域

- Referer：发出请求的页面的URL

- User-Agent：浏览器的用户代理字符串

### HTTP Response Header常见响应头：

- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- content-type:表示后面的文档属于什么MIME类型

### 常见的 Content-Type 属性值：

- application/x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码。

- multipart/form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。

- application/json：服务器消息主体是序列化后的 JSON 字符串。

- text/xml：该种方式主要用来提交 XML 格式的数据。

### 浏览器输入url会发生什么

1. 解析url：确定传输协议和请求资源的路径。
2. 缓存判断：判断浏览器是否有缓存，如果有直接使用，没有的话再向服务器发起请求。
3. dns解析：根据url获取域名的IP地址，检查缓存，没有的话再想本地的DNS服务器发起请求，检查缓存，后面再向根域名服务器、顶级域名服务器请求，一级一级的往上去找。
4. 获取mac地址：通过IP地址和子网掩码判断是否在同一个子网里，通过网关进行转发。
5. TCP三次握手：1.客户端向服务端发送一个SYN的连接请求报文和一个随机序号2.服务端接收到后发送一个SYN ACK报文和一个随机序号确认连接请求3.客户端接受服务器的确认应答后，进入连接建立的状态，同时向服务器发送一个ACK的确认报文，服务端接收到去人之后，连接建立成功。
6. HTTPS握手
7. 返回数据
8. 页面渲染
9. TCP四次握手

| 类别 | 原因         | 描述                     |
| ---- | ------------ | ------------------------ |
| 1XX  | 信息性状态码 | 接受的请求正在处理       |
| 2XX  | 成功状态码   | 请求正常处理完毕         |
| 3XX  | 重定向       | 需要进行附加操作完成请求 |
| 4XX  | 客户端错误   | 服务器无法处理请求       |
| 5XX  | 服务端错误   | 服务器处理请求出错       |

常见的状态码：

- **200**：请求成功
- **301**：永久重定向
- **302**：临时重定向
- **304**：自上次请求，未修改的文件
- **400**：错误请求
- **401**：未被授权，需要身份验证，例如token信息等等
- **403**：请求被拒绝
- **404**：资源缺失，接口不存在或请求的文件不存在等等
- **500**：服务器未知错误
- **502**：服务挂了，网关错误，Nginx上常见
- **503**：服务暂时无法使用

### http缓存

http缓存分两种：1. **强制缓存** 2.**协商缓存**。两种都是通过HTTP响应头控制缓存。

#### 强制缓存：

再次请求时无需再向服务器发送请求，相关Response Headers：

- `Expires`：使用绝对时间，且有固定格式，`Expires: Mon, 25 Oct 2021 20:11:12 GMT`
- `Cache-Control`，具有强大的缓存控制能力
  - `no-cache`，每次都求需要校验服务器资源的新鲜度
  - `max-age=31536000`，浏览器在一年内都不需要向服务器请求资源

#### 协商缓存：

再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回304，从浏览器获取资源，相关的Request/Response Headers：

- `Last-Modified` / `If-Modified-Since`
- `Etag` / `If-None-Match`

#### Etag：

Etag的生成是由服务器的算法决定的，比如常见的Nginx的etag由last_modified和content_leng组成。如果Etag改变了，并不意味着内容一定更改了，有一种情况是编辑了文件，但并没有改变内容，此时last_modified就会改变，etag自然也会改变。

### Http1.0与http1.1的区别：

1. 连接方面，1.0是非持久性连接的，1.1是持久性连接的，减少连接时每次都需要建立连接的时延。
2. 资源方面，1.0存在浪费带宽的问题，把所有的东西都丢过来，而且不支持断点续传
3. 1.1新增了host字段
4. 1.1新增了一些请求方法，比如put、options

### http2与http1.1有什么改进

1. 二进制分帧，把头数据和数据体分为头信息帧和数据帧，这个也是实现多路复用的基础。
2. 请求多路复用（Stream/Frame），客户端和 服务器可以同时发送多个请求和回应，不用按照顺序。
3. 头部压缩（HPack），1.1的协议不带状态，每次请求都会附带所有的信息，浪费带宽。
4. 服务端推送（PUSH_PROMISE），可以推送一些静态资源，减少延迟。

### HTTP和HTTPS的区别：

- HTTPS需要CA证书，HTTP不需要
- HTTP的协议是超文本传输协议，信息是明文传输的，HTTPS则是SSL加密的传输协议
- 连接方式不同，端口不同，HTTP默认端口80，HTTPS默认端口是443

### gzip原理及如何配置

gzip用于HTTP文件传输中，比如JS、CSS等，但`一般不会压缩图片`。配置方法：

1. 在HTTP Response报文中，用`Content-Encoding`指明使用gzip压缩
2. 在nginx反向代理那一层，`gzip on`

